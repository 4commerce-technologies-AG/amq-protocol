# encoding: binary

# THIS IS AN AUTOGENERATED FILE, DO NOT MODIFY
# IT DIRECTLY ! FOR CHANGES, PLEASE UPDATE CODEGEN.PY
# IN THE ROOT DIRECTORY OF THE AMQ-PROTOCOL REPOSITORY.

require_relative "table.rb"
require_relative "frame.rb"

module AMQ
  module Protocol
    PROTOCOL_VERSION = "0.9.1"
    PREAMBLE = "AMQP\x00\x00\x09\x01"
    DEFAULT_PORT = 5672

    # caching
    EMPTY_STRING = "".freeze

    # @version 0.0.1
    # @return [Array] Collection of subclasses of AMQ::Protocol::Class.
    def self.classes
      Class.classes
    end

    # @version 0.0.1
    # @return [Array] Collection of subclasses of AMQ::Protocol::Method.
    def self.methods
      Method.methods
    end

    class Error < StandardError
      def self.[](code) # TODO: rewrite more effectively
        ObjectSpace.each_object(::Class) do |klass|
          return klass if klass < self && (klass.const_defined?(:VALUE) && klass::VALUE == code)
        end
        raise "No such exception class for code #{code}"
      end

      def initialize(message = "AMQP error")
        super(message)
      end
    end

    class FrameTypeError < Error
      def initialize(types)
        super("Must be one of #{types.inspect}")
      end
    end

    class EmptyResponseError < Error
      def initialize(message = "Empty response received from the server.")
        super(message)
      end
    end

    class BadResponseError < Error
      def initialize(argument, expected, actual)
        super("Argument #{argument} has to be #{expected.inspect}, was #{data.inspect}")
      end
    end

    class SoftError < Error
    end

    class HardError < Error
    end

    class ContentTooLarge < SoftError
      VALUE = 311
    end

    class NoRoute < SoftError
      VALUE = 312
    end

    class NoConsumers < SoftError
      VALUE = 313
    end

    class AccessRefused < SoftError
      VALUE = 403
    end

    class NotFound < SoftError
      VALUE = 404
    end

    class ResourceLocked < SoftError
      VALUE = 405
    end

    class PreconditionFailed < SoftError
      VALUE = 406
    end

    class ConnectionForced < HardError
      VALUE = 320
    end

    class InvalidPath < HardError
      VALUE = 402
    end

    class FrameError < HardError
      VALUE = 501
    end

    class SyntaxError < HardError
      VALUE = 502
    end

    class CommandInvalid < HardError
      VALUE = 503
    end

    class ChannelError < HardError
      VALUE = 504
    end

    class UnexpectedFrame < HardError
      VALUE = 505
    end

    class ResourceError < HardError
      VALUE = 506
    end

    class NotAllowed < HardError
      VALUE = 530
    end

    class NotImplemented < HardError
      VALUE = 540
    end

    class InternalError < HardError
      VALUE = 541
    end

    # We don"t instantiate the following classes,
    # as we don"t actually need any per-instance state.
    # Also, this is pretty low-level functionality,
    # hence it should have a reasonable performance.
    # As everyone knows, garbage collector in MRI performs
    # really badly, which is another good reason for
    # not creating any objects, but only use class as
    # a struct. Creating classes is quite expensive though,
    # but here the inheritance comes handy and mainly
    # as we can"t simply make a reference to a function,
    # we can"t use a hash or an object. I"ve been also
    # considering to have just a bunch of methods, but
    # here"s the problem, that after we"d require this file,
    # all these methods would become global which would
    # be a bad, bad thing to do.
    class Class
      @@classes = Array.new

      def self.method_id
        @method_id
      end

      def self.name
        @name
      end

      def self.inherited(base)
        if self == Class
          @@classes << base
        end
      end

      def self.classes
        @@classes
      end
    end

    class Method
      @@methods = Array.new
      def self.method_id
        @method_id
      end

      def self.name
        @name
      end

      def self.index
        @index
      end

      def self.inherited(base)
        if self == Method
          @@methods << base
        end
      end

      def self.methods
        @@methods
      end

      def self.split_headers(user_headers)
        properties, headers = {}, {}
        user_headers.each do |key, value|
          if Basic::PROPERTIES.has_key?(key) or Basic::PROPERTIES.has_key?(key.to_sym)
            properties[key] = value
          else
            headers[key] = value
          end
        end

        return props, headers
      end

      def self.encode_body(body, frame_size)
        # Spec is broken: Our errata says that it does define
        # something, but it just doesn"t relate do method and
        # properties frames. Which makes it, well, suboptimal.
        # https://dev.rabbitmq.com/wiki/Amqp091Errata#section_11
        limit = frame_size - 7 - 1

        Array.new.tap do |array|
          while body
            payload, body = body[0..limit], body[limit..-1]
            # array << [0x03, payload]
            array << BodyFrame.new(payload)
          end
        end
      end

      # We can return different:
      # - instantiate given subclass of Method
      # - create an OpenStruct object
      # - create a hash
      # - yield params into the block rather than just return
      # @api plugin
      def self.instantiate(*args, &block)
        self.new(*args, &block)
        # or OpenStruct.new(args.first)
        # or args.first
        # or block.call(*args)
      end
    end

    class Connection < Class
      @name = "connection"
      @method_id = 10

      class Start < Method
        @name = "connection.start"
        @method_id = 10
        @index = 0x000A000A # 10, 10, 655370

        # @return
        # ["version_major = 0", "version_minor = 9", "server properties = 0", "mechanisms = "PLAIN"", "locales = "en_US""]
        def self.encode(version_major, version_minor, server_properties, mechanisms, locales)
          pieces = []
          pieces << [10, 10].pack("n2")
          pieces << [version_major].pack("B")
          pieces << [version_minor].pack("B")
          pieces << AMQ::Protocol::Table.encode(server_properties)
          pieces << [mechanisms.bytesize].pack("N")
          pieces << mechanisms
          pieces << [locales.bytesize].pack("N")
          pieces << locales
          buffer = pieces.join("")
          MethodFrame.new(buffer)
        end
      end

      class StartOk < Method
        @name = "connection.start-ok"
        @method_id = 11
        @index = 0x000A000B # 10, 11, 655371

        # @return
        def self.decode(data)
          offset = 0
          table_length = Table.length(data[offset..(offset + 4)])
          client_properties = Table.decode(data[offset..table_length])
          length = data[offset..(offset + 1)].unpack("c")[0]
          offset += 1
          mechanism = data[offset..(offset + length)]
          offset += length
          length = data[offset..(offset + 4)].unpack("N").first
          offset += 4
          response = data[offset..(offset + length)]
          offset += length
          length = data[offset..(offset + 1)].unpack("c")[0]
          offset += 1
          locale = data[offset..(offset + length)]
          offset += length
          self.new(client_properties, mechanism, response, locale)
        end

        attr_reader :client_properties, :mechanism, :response, :locale
        def initialize(client_properties, mechanism, response, locale)
          @client_properties = client_properties
          @mechanism = mechanism
          @response = response
          @locale = locale
        end
      end

      class Secure < Method
        @name = "connection.secure"
        @method_id = 20
        @index = 0x000A0014 # 10, 20, 655380

        # @return
        # ["challenge = 0"]
        def self.encode(challenge)
          pieces = []
          pieces << [10, 20].pack("n2")
          pieces << [challenge.bytesize].pack("N")
          pieces << challenge
          buffer = pieces.join("")
          MethodFrame.new(buffer)
        end
      end

      class SecureOk < Method
        @name = "connection.secure-ok"
        @method_id = 21
        @index = 0x000A0015 # 10, 21, 655381

        # @return
        def self.decode(data)
          offset = 0
          length = data[offset..(offset + 4)].unpack("N").first
          offset += 4
          response = data[offset..(offset + length)]
          offset += length
          self.new(response)
        end

        attr_reader :response
        def initialize(response)
          @response = response
        end
      end

      class Tune < Method
        @name = "connection.tune"
        @method_id = 30
        @index = 0x000A001E # 10, 30, 655390

        # @return
        # ["channel_max = 0", "frame_max = 0", "heartbeat = 0"]
        def self.encode(channel_max, frame_max, heartbeat)
          pieces = []
          pieces << [10, 30].pack("n2")
          pieces << [channel_max].pack("n")
          pieces << [frame_max].pack("N")
          pieces << [heartbeat].pack("n")
          buffer = pieces.join("")
          MethodFrame.new(buffer)
        end
      end

      class TuneOk < Method
        @name = "connection.tune-ok"
        @method_id = 31
        @index = 0x000A001F # 10, 31, 655391

        # @return
        def self.decode(data)
          offset = 0
          channel_max = data[offset..(offset + 2)].unpack("n").first
          offset += 2
          frame_max = data[offset..(offset + 4)].unpack("N").first
          offset += 4
          heartbeat = data[offset..(offset + 2)].unpack("n").first
          offset += 2
          self.new(channel_max, frame_max, heartbeat)
        end

        attr_reader :channel_max, :frame_max, :heartbeat
        def initialize(channel_max, frame_max, heartbeat)
          @channel_max = channel_max
          @frame_max = frame_max
          @heartbeat = heartbeat
        end
      end

      class Open < Method
        @name = "connection.open"
        @method_id = 40
        @index = 0x000A0028 # 10, 40, 655400

        # @return
        def self.decode(data)
          offset = 0
          length = data[offset..(offset + 1)].unpack("c")[0]
          offset += 1
          virtual_host = data[offset..(offset + length)]
          offset += length
          length = data[offset..(offset + 1)].unpack("c")[0]
          offset += 1
          capabilities = data[offset..(offset + length)]
          offset += length
          bit_buffer = data[offset..(offset + 1)].unpack("c").first
          offset += 1
          insist = (bit_buffer & (1 << 0)) != 0
          self.new(virtual_host, capabilities, insist)
        end

        attr_reader :virtual_host, :capabilities, :insist
        def initialize(virtual_host, capabilities, insist)
          @virtual_host = virtual_host
          @capabilities = capabilities
          @insist = insist
        end
      end

      class OpenOk < Method
        @name = "connection.open-ok"
        @method_id = 41
        @index = 0x000A0029 # 10, 41, 655401

        # @return
        # ["known_hosts = """]
        def self.encode(known_hosts)
          pieces = []
          pieces << [10, 41].pack("n2")
          pieces << known_hosts.bytesize.chr
          pieces << known_hosts
          buffer = pieces.join("")
          MethodFrame.new(buffer)
        end
      end

      class Close < Method
        @name = "connection.close"
        @method_id = 50
        @index = 0x000A0032 # 10, 50, 655410

        # @return
        def self.decode(data)
          offset = 0
          reply_code = data[offset..(offset + 2)].unpack("n").first
          offset += 2
          length = data[offset..(offset + 1)].unpack("c")[0]
          offset += 1
          reply_text = data[offset..(offset + length)]
          offset += length
          class_id = data[offset..(offset + 2)].unpack("n").first
          offset += 2
          method_id = data[offset..(offset + 2)].unpack("n").first
          offset += 2
          if reply_code.eql?(200)
            self.new(reply_code, reply_text, class_id, method_id)
          else
            raise Error[reply_code].new(reply_text)
          end
        end

        attr_reader :reply_code, :reply_text, :class_id, :method_id
        def initialize(reply_code, reply_text, class_id, method_id)
          @reply_code = reply_code
          @reply_text = reply_text
          @class_id = class_id
          @method_id = method_id
        end

        # @return
        # ["reply_code = 0", "reply_text = """, "class_id = 0", "method_id = 0"]
        def self.encode(reply_code, reply_text, class_id, method_id)
          pieces = []
          pieces << [10, 50].pack("n2")
          pieces << [reply_code].pack("n")
          pieces << reply_text.bytesize.chr
          pieces << reply_text
          pieces << [class_id].pack("n")
          pieces << [method_id].pack("n")
          buffer = pieces.join("")
          MethodFrame.new(buffer)
        end
      end

      class CloseOk < Method
        @name = "connection.close-ok"
        @method_id = 51
        @index = 0x000A0033 # 10, 51, 655411

        # @return
        def self.decode(data)
          offset = 0
          self.new()
        end

        def initialize()
        end

        # @return
        # []
        def self.encode()
          pieces = []
          pieces << [10, 51].pack("n2")
          buffer = pieces.join("")
          MethodFrame.new(buffer)
        end
      end
    end

    class Channel < Class
      @name = "channel"
      @method_id = 20

      class Open < Method
        @name = "channel.open"
        @method_id = 10
        @index = 0x0014000A # 20, 10, 1310730

        # @return
        def self.decode(data)
          offset = 0
          length = data[offset..(offset + 1)].unpack("c")[0]
          offset += 1
          out_of_band = data[offset..(offset + length)]
          offset += length
          self.new(out_of_band)
        end

        attr_reader :out_of_band
        def initialize(out_of_band)
          @out_of_band = out_of_band
        end
      end

      class OpenOk < Method
        @name = "channel.open-ok"
        @method_id = 11
        @index = 0x0014000B # 20, 11, 1310731

        # @return
        # ["channel_id = """]
        def self.encode(channel_id)
          pieces = []
          pieces << [20, 11].pack("n2")
          pieces << [channel_id.bytesize].pack("N")
          pieces << channel_id
          buffer = pieces.join("")
          MethodFrame.new(buffer)
        end
      end

      class Flow < Method
        @name = "channel.flow"
        @method_id = 20
        @index = 0x00140014 # 20, 20, 1310740

        # @return
        def self.decode(data)
          offset = 0
          bit_buffer = data[offset..(offset + 1)].unpack("c").first
          offset += 1
          active = (bit_buffer & (1 << 0)) != 0
          self.new(active)
        end

        attr_reader :active
        def initialize(active)
          @active = active
        end

        # @return
        # ["active = 0"]
        def self.encode(active)
          pieces = []
          pieces << [20, 20].pack("n2")
          bit_buffer = 0
          bit_buffer = bit_buffer | (1 << 0) if active
          pieces << [bit_buffer].pack("c")
          buffer = pieces.join("")
          MethodFrame.new(buffer)
        end
      end

      class FlowOk < Method
        @name = "channel.flow-ok"
        @method_id = 21
        @index = 0x00140015 # 20, 21, 1310741

        # @return
        def self.decode(data)
          offset = 0
          bit_buffer = data[offset..(offset + 1)].unpack("c").first
          offset += 1
          active = (bit_buffer & (1 << 0)) != 0
          self.new(active)
        end

        attr_reader :active
        def initialize(active)
          @active = active
        end

        # @return
        # ["active = 0"]
        def self.encode(active)
          pieces = []
          pieces << [20, 21].pack("n2")
          bit_buffer = 0
          bit_buffer = bit_buffer | (1 << 0) if active
          pieces << [bit_buffer].pack("c")
          buffer = pieces.join("")
          MethodFrame.new(buffer)
        end
      end

      class Close < Method
        @name = "channel.close"
        @method_id = 40
        @index = 0x00140028 # 20, 40, 1310760

        # @return
        def self.decode(data)
          offset = 0
          reply_code = data[offset..(offset + 2)].unpack("n").first
          offset += 2
          length = data[offset..(offset + 1)].unpack("c")[0]
          offset += 1
          reply_text = data[offset..(offset + length)]
          offset += length
          class_id = data[offset..(offset + 2)].unpack("n").first
          offset += 2
          method_id = data[offset..(offset + 2)].unpack("n").first
          offset += 2
          if reply_code.eql?(200)
            self.new(reply_code, reply_text, class_id, method_id)
          else
            raise Error[reply_code].new(reply_text)
          end
        end

        attr_reader :reply_code, :reply_text, :class_id, :method_id
        def initialize(reply_code, reply_text, class_id, method_id)
          @reply_code = reply_code
          @reply_text = reply_text
          @class_id = class_id
          @method_id = method_id
        end

        # @return
        # ["reply_code = 0", "reply_text = """, "class_id = 0", "method_id = 0"]
        def self.encode(reply_code, reply_text, class_id, method_id)
          pieces = []
          pieces << [20, 40].pack("n2")
          pieces << [reply_code].pack("n")
          pieces << reply_text.bytesize.chr
          pieces << reply_text
          pieces << [class_id].pack("n")
          pieces << [method_id].pack("n")
          buffer = pieces.join("")
          MethodFrame.new(buffer)
        end
      end

      class CloseOk < Method
        @name = "channel.close-ok"
        @method_id = 41
        @index = 0x00140029 # 20, 41, 1310761

        # @return
        def self.decode(data)
          offset = 0
          self.new()
        end

        def initialize()
        end

        # @return
        # []
        def self.encode()
          pieces = []
          pieces << [20, 41].pack("n2")
          buffer = pieces.join("")
          MethodFrame.new(buffer)
        end
      end
    end

    class Exchange < Class
      @name = "exchange"
      @method_id = 40

      class Declare < Method
        @name = "exchange.declare"
        @method_id = 10
        @index = 0x0028000A # 40, 10, 2621450

        # @return
        def self.decode(data)
          offset = 0
          ticket = data[offset..(offset + 2)].unpack("n").first
          offset += 2
          length = data[offset..(offset + 1)].unpack("c")[0]
          offset += 1
          exchange = data[offset..(offset + length)]
          offset += length
          length = data[offset..(offset + 1)].unpack("c")[0]
          offset += 1
          type = data[offset..(offset + length)]
          offset += length
          bit_buffer = data[offset..(offset + 1)].unpack("c").first
          offset += 1
          passive = (bit_buffer & (1 << 0)) != 0
          table_length = Table.length(data[offset..(offset + 4)])
          arguments = Table.decode(data[offset..table_length])
          self.new(ticket, exchange, type, passive, durable, auto_delete, internal, nowait, arguments)
        end

        attr_reader :ticket, :exchange, :type, :passive, :durable, :auto_delete, :internal, :nowait, :arguments
        def initialize(ticket, exchange, type, passive, durable, auto_delete, internal, nowait, arguments)
          @ticket = ticket
          @exchange = exchange
          @type = type
          @passive = passive
          @durable = durable
          @auto_delete = auto_delete
          @internal = internal
          @nowait = nowait
          @arguments = arguments
        end
      end

      class DeclareOk < Method
        @name = "exchange.declare-ok"
        @method_id = 11
        @index = 0x0028000B # 40, 11, 2621451

        # @return
        # []
        def self.encode()
          pieces = []
          pieces << [40, 11].pack("n2")
          buffer = pieces.join("")
          MethodFrame.new(buffer)
        end
      end

      class Delete < Method
        @name = "exchange.delete"
        @method_id = 20
        @index = 0x00280014 # 40, 20, 2621460

        # @return
        def self.decode(data)
          offset = 0
          ticket = data[offset..(offset + 2)].unpack("n").first
          offset += 2
          length = data[offset..(offset + 1)].unpack("c")[0]
          offset += 1
          exchange = data[offset..(offset + length)]
          offset += length
          bit_buffer = data[offset..(offset + 1)].unpack("c").first
          offset += 1
          if_unused = (bit_buffer & (1 << 0)) != 0
          self.new(ticket, exchange, if_unused, nowait)
        end

        attr_reader :ticket, :exchange, :if_unused, :nowait
        def initialize(ticket, exchange, if_unused, nowait)
          @ticket = ticket
          @exchange = exchange
          @if_unused = if_unused
          @nowait = nowait
        end
      end

      class DeleteOk < Method
        @name = "exchange.delete-ok"
        @method_id = 21
        @index = 0x00280015 # 40, 21, 2621461

        # @return
        # []
        def self.encode()
          pieces = []
          pieces << [40, 21].pack("n2")
          buffer = pieces.join("")
          MethodFrame.new(buffer)
        end
      end

      class Bind < Method
        @name = "exchange.bind"
        @method_id = 30
        @index = 0x0028001E # 40, 30, 2621470

        # @return
        def self.decode(data)
          offset = 0
          ticket = data[offset..(offset + 2)].unpack("n").first
          offset += 2
          length = data[offset..(offset + 1)].unpack("c")[0]
          offset += 1
          destination = data[offset..(offset + length)]
          offset += length
          length = data[offset..(offset + 1)].unpack("c")[0]
          offset += 1
          source = data[offset..(offset + length)]
          offset += length
          length = data[offset..(offset + 1)].unpack("c")[0]
          offset += 1
          routing_key = data[offset..(offset + length)]
          offset += length
          bit_buffer = data[offset..(offset + 1)].unpack("c").first
          offset += 1
          nowait = (bit_buffer & (1 << 0)) != 0
          table_length = Table.length(data[offset..(offset + 4)])
          arguments = Table.decode(data[offset..table_length])
          self.new(ticket, destination, source, routing_key, nowait, arguments)
        end

        attr_reader :ticket, :destination, :source, :routing_key, :nowait, :arguments
        def initialize(ticket, destination, source, routing_key, nowait, arguments)
          @ticket = ticket
          @destination = destination
          @source = source
          @routing_key = routing_key
          @nowait = nowait
          @arguments = arguments
        end
      end

      class BindOk < Method
        @name = "exchange.bind-ok"
        @method_id = 31
        @index = 0x0028001F # 40, 31, 2621471

        # @return
        # []
        def self.encode()
          pieces = []
          pieces << [40, 31].pack("n2")
          buffer = pieces.join("")
          MethodFrame.new(buffer)
        end
      end

      class Unbind < Method
        @name = "exchange.unbind"
        @method_id = 40
        @index = 0x00280028 # 40, 40, 2621480

        # @return
        def self.decode(data)
          offset = 0
          ticket = data[offset..(offset + 2)].unpack("n").first
          offset += 2
          length = data[offset..(offset + 1)].unpack("c")[0]
          offset += 1
          destination = data[offset..(offset + length)]
          offset += length
          length = data[offset..(offset + 1)].unpack("c")[0]
          offset += 1
          source = data[offset..(offset + length)]
          offset += length
          length = data[offset..(offset + 1)].unpack("c")[0]
          offset += 1
          routing_key = data[offset..(offset + length)]
          offset += length
          bit_buffer = data[offset..(offset + 1)].unpack("c").first
          offset += 1
          nowait = (bit_buffer & (1 << 0)) != 0
          table_length = Table.length(data[offset..(offset + 4)])
          arguments = Table.decode(data[offset..table_length])
          self.new(ticket, destination, source, routing_key, nowait, arguments)
        end

        attr_reader :ticket, :destination, :source, :routing_key, :nowait, :arguments
        def initialize(ticket, destination, source, routing_key, nowait, arguments)
          @ticket = ticket
          @destination = destination
          @source = source
          @routing_key = routing_key
          @nowait = nowait
          @arguments = arguments
        end
      end

      class UnbindOk < Method
        @name = "exchange.unbind-ok"
        @method_id = 51
        @index = 0x00280033 # 40, 51, 2621491

        # @return
        # []
        def self.encode()
          pieces = []
          pieces << [40, 51].pack("n2")
          buffer = pieces.join("")
          MethodFrame.new(buffer)
        end
      end
    end

    class Queue < Class
      @name = "queue"
      @method_id = 50

      class Declare < Method
        @name = "queue.declare"
        @method_id = 10
        @index = 0x0032000A # 50, 10, 3276810

        # @return
        def self.decode(data)
          offset = 0
          ticket = data[offset..(offset + 2)].unpack("n").first
          offset += 2
          length = data[offset..(offset + 1)].unpack("c")[0]
          offset += 1
          queue = data[offset..(offset + length)]
          offset += length
          bit_buffer = data[offset..(offset + 1)].unpack("c").first
          offset += 1
          passive = (bit_buffer & (1 << 0)) != 0
          table_length = Table.length(data[offset..(offset + 4)])
          arguments = Table.decode(data[offset..table_length])
          self.new(ticket, queue, passive, durable, exclusive, auto_delete, nowait, arguments)
        end

        attr_reader :ticket, :queue, :passive, :durable, :exclusive, :auto_delete, :nowait, :arguments
        def initialize(ticket, queue, passive, durable, exclusive, auto_delete, nowait, arguments)
          @ticket = ticket
          @queue = queue
          @passive = passive
          @durable = durable
          @exclusive = exclusive
          @auto_delete = auto_delete
          @nowait = nowait
          @arguments = arguments
        end
      end

      class DeclareOk < Method
        @name = "queue.declare-ok"
        @method_id = 11
        @index = 0x0032000B # 50, 11, 3276811

        # @return
        # ["queue = 0", "message_count = 0", "consumer_count = 0"]
        def self.encode(queue, message_count, consumer_count)
          pieces = []
          pieces << [50, 11].pack("n2")
          pieces << queue.bytesize.chr
          pieces << queue
          pieces << [message_count].pack("N")
          pieces << [consumer_count].pack("N")
          buffer = pieces.join("")
          MethodFrame.new(buffer)
        end
      end

      class Bind < Method
        @name = "queue.bind"
        @method_id = 20
        @index = 0x00320014 # 50, 20, 3276820

        # @return
        def self.decode(data)
          offset = 0
          ticket = data[offset..(offset + 2)].unpack("n").first
          offset += 2
          length = data[offset..(offset + 1)].unpack("c")[0]
          offset += 1
          queue = data[offset..(offset + length)]
          offset += length
          length = data[offset..(offset + 1)].unpack("c")[0]
          offset += 1
          exchange = data[offset..(offset + length)]
          offset += length
          length = data[offset..(offset + 1)].unpack("c")[0]
          offset += 1
          routing_key = data[offset..(offset + length)]
          offset += length
          bit_buffer = data[offset..(offset + 1)].unpack("c").first
          offset += 1
          nowait = (bit_buffer & (1 << 0)) != 0
          table_length = Table.length(data[offset..(offset + 4)])
          arguments = Table.decode(data[offset..table_length])
          self.new(ticket, queue, exchange, routing_key, nowait, arguments)
        end

        attr_reader :ticket, :queue, :exchange, :routing_key, :nowait, :arguments
        def initialize(ticket, queue, exchange, routing_key, nowait, arguments)
          @ticket = ticket
          @queue = queue
          @exchange = exchange
          @routing_key = routing_key
          @nowait = nowait
          @arguments = arguments
        end
      end

      class BindOk < Method
        @name = "queue.bind-ok"
        @method_id = 21
        @index = 0x00320015 # 50, 21, 3276821

        # @return
        # []
        def self.encode()
          pieces = []
          pieces << [50, 21].pack("n2")
          buffer = pieces.join("")
          MethodFrame.new(buffer)
        end
      end

      class Purge < Method
        @name = "queue.purge"
        @method_id = 30
        @index = 0x0032001E # 50, 30, 3276830

        # @return
        def self.decode(data)
          offset = 0
          ticket = data[offset..(offset + 2)].unpack("n").first
          offset += 2
          length = data[offset..(offset + 1)].unpack("c")[0]
          offset += 1
          queue = data[offset..(offset + length)]
          offset += length
          bit_buffer = data[offset..(offset + 1)].unpack("c").first
          offset += 1
          nowait = (bit_buffer & (1 << 0)) != 0
          self.new(ticket, queue, nowait)
        end

        attr_reader :ticket, :queue, :nowait
        def initialize(ticket, queue, nowait)
          @ticket = ticket
          @queue = queue
          @nowait = nowait
        end
      end

      class PurgeOk < Method
        @name = "queue.purge-ok"
        @method_id = 31
        @index = 0x0032001F # 50, 31, 3276831

        # @return
        # ["message_count = 0"]
        def self.encode(message_count)
          pieces = []
          pieces << [50, 31].pack("n2")
          pieces << [message_count].pack("N")
          buffer = pieces.join("")
          MethodFrame.new(buffer)
        end
      end

      class Delete < Method
        @name = "queue.delete"
        @method_id = 40
        @index = 0x00320028 # 50, 40, 3276840

        # @return
        def self.decode(data)
          offset = 0
          ticket = data[offset..(offset + 2)].unpack("n").first
          offset += 2
          length = data[offset..(offset + 1)].unpack("c")[0]
          offset += 1
          queue = data[offset..(offset + length)]
          offset += length
          bit_buffer = data[offset..(offset + 1)].unpack("c").first
          offset += 1
          if_unused = (bit_buffer & (1 << 0)) != 0
          self.new(ticket, queue, if_unused, if_empty, nowait)
        end

        attr_reader :ticket, :queue, :if_unused, :if_empty, :nowait
        def initialize(ticket, queue, if_unused, if_empty, nowait)
          @ticket = ticket
          @queue = queue
          @if_unused = if_unused
          @if_empty = if_empty
          @nowait = nowait
        end
      end

      class DeleteOk < Method
        @name = "queue.delete-ok"
        @method_id = 41
        @index = 0x00320029 # 50, 41, 3276841

        # @return
        # ["message_count = 0"]
        def self.encode(message_count)
          pieces = []
          pieces << [50, 41].pack("n2")
          pieces << [message_count].pack("N")
          buffer = pieces.join("")
          MethodFrame.new(buffer)
        end
      end

      class Unbind < Method
        @name = "queue.unbind"
        @method_id = 50
        @index = 0x00320032 # 50, 50, 3276850

        # @return
        def self.decode(data)
          offset = 0
          ticket = data[offset..(offset + 2)].unpack("n").first
          offset += 2
          length = data[offset..(offset + 1)].unpack("c")[0]
          offset += 1
          queue = data[offset..(offset + length)]
          offset += length
          length = data[offset..(offset + 1)].unpack("c")[0]
          offset += 1
          exchange = data[offset..(offset + length)]
          offset += length
          length = data[offset..(offset + 1)].unpack("c")[0]
          offset += 1
          routing_key = data[offset..(offset + length)]
          offset += length
          table_length = Table.length(data[offset..(offset + 4)])
          arguments = Table.decode(data[offset..table_length])
          self.new(ticket, queue, exchange, routing_key, arguments)
        end

        attr_reader :ticket, :queue, :exchange, :routing_key, :arguments
        def initialize(ticket, queue, exchange, routing_key, arguments)
          @ticket = ticket
          @queue = queue
          @exchange = exchange
          @routing_key = routing_key
          @arguments = arguments
        end
      end

      class UnbindOk < Method
        @name = "queue.unbind-ok"
        @method_id = 51
        @index = 0x00320033 # 50, 51, 3276851

        # @return
        # []
        def self.encode()
          pieces = []
          pieces << [50, 51].pack("n2")
          buffer = pieces.join("")
          MethodFrame.new(buffer)
        end
      end
    end

    class Basic < Class
      @name = "basic"
      @method_id = 60

      PROPERTIES = [
        :content_type, # shortstr
        :content_encoding, # shortstr
        :headers, # table
        :delivery_mode, # octet
        :priority, # octet
        :correlation_id, # shortstr
        :reply_to, # shortstr
        :expiration, # shortstr
        :message_id, # shortstr
        :timestamp, # timestamp
        :type, # shortstr
        :user_id, # shortstr
        :app_id, # shortstr
        :cluster_id, # shortstr
      ]

      # 1 << 15
      def self.encode_content_type(value)
        pieces = []
        pieces << result.bytesize.chr
        pieces << result
        [0, 0x8000, result]
      end

      # 1 << 14
      def self.encode_content_encoding(value)
        pieces = []
        pieces << result.bytesize.chr
        pieces << result
        [1, 0x4000, result]
      end

      # 1 << 13
      def self.encode_headers(value)
        pieces = []
        pieces << AMQ::Protocol::Table.encode(result)
        [2, 0x2000, result]
      end

      # 1 << 12
      def self.encode_delivery_mode(value)
        pieces = []
        pieces << [result].pack("B")
        [3, 0x1000, result]
      end

      # 1 << 11
      def self.encode_priority(value)
        pieces = []
        pieces << [result].pack("B")
        [4, 0x0800, result]
      end

      # 1 << 10
      def self.encode_correlation_id(value)
        pieces = []
        pieces << result.bytesize.chr
        pieces << result
        [5, 0x0400, result]
      end

      # 1 << 9
      def self.encode_reply_to(value)
        pieces = []
        pieces << result.bytesize.chr
        pieces << result
        [6, 0x0200, result]
      end

      # 1 << 8
      def self.encode_expiration(value)
        pieces = []
        pieces << result.bytesize.chr
        pieces << result
        [7, 0x0100, result]
      end

      # 1 << 7
      def self.encode_message_id(value)
        pieces = []
        pieces << result.bytesize.chr
        pieces << result
        [8, 0x0080, result]
      end

      # 1 << 6
      def self.encode_timestamp(value)
        pieces = []
        pieces << [result].pack(">Q")
        [9, 0x0040, result]
      end

      # 1 << 5
      def self.encode_type(value)
        pieces = []
        pieces << result.bytesize.chr
        pieces << result
        [10, 0x0020, result]
      end

      # 1 << 4
      def self.encode_user_id(value)
        pieces = []
        pieces << result.bytesize.chr
        pieces << result
        [11, 0x0010, result]
      end

      # 1 << 3
      def self.encode_app_id(value)
        pieces = []
        pieces << result.bytesize.chr
        pieces << result
        [12, 0x0008, result]
      end

      # 1 << 2
      def self.encode_cluster_id(value)
        pieces = []
        pieces << result.bytesize.chr
        pieces << result
        [13, 0x0004, result]
      end

      def self.encode_properties(body_size, properties)
        pieces = Array.new(14) { AMQ::Protocol::EMPTY_STRING }
        flags = 0

        properties.each do |key, value|
          i, f, result = self.send(:"encode_#{key}", value)
          flags |= f
          pieces[i] = result
        end

        result = [CLASS_BASIC, 0, body_size, flags].pack("!HHQH")
        [0x02, result, pieces.join("")].join("")
      end

      #def self.decode_properties
      #  print "def %s(data, offset):" % (c.decode,)
      #  print "    props = {}"
      #  print "    flags, = struct.unpack_from("!H", data, offset)"
      #  print "    offset += 2"
      #  print "    assert (flags & 0x01) == 0"
      #  for i, f in enumerate(c.fields):
      #      print "    if (flags & 0x%04x): # 1 << %i" % (1 << (15-i), 15-i)
      #      fields = codegen_helpers.UnpackWrapper()
      #      fields.add(f.n, f.t)
      #      fields.do_print(" "*8, "props["%s"]")
      #  print "    return props, offset"
      #end

      class Qos < Method
        @name = "basic.qos"
        @method_id = 10
        @index = 0x003C000A # 60, 10, 3932170

        # @return
        def self.decode(data)
          offset = 0
          prefetch_size = data[offset..(offset + 4)].unpack("N").first
          offset += 4
          prefetch_count = data[offset..(offset + 2)].unpack("n").first
          offset += 2
          bit_buffer = data[offset..(offset + 1)].unpack("c").first
          offset += 1
          global = (bit_buffer & (1 << 0)) != 0
          self.new(prefetch_size, prefetch_count, global)
        end

        attr_reader :prefetch_size, :prefetch_count, :global
        def initialize(prefetch_size, prefetch_count, global)
          @prefetch_size = prefetch_size
          @prefetch_count = prefetch_count
          @global = global
        end
      end

      class QosOk < Method
        @name = "basic.qos-ok"
        @method_id = 11
        @index = 0x003C000B # 60, 11, 3932171

        # @return
        # []
        def self.encode()
          pieces = []
          pieces << [60, 11].pack("n2")
          buffer = pieces.join("")
          MethodFrame.new(buffer)
        end
      end

      class Consume < Method
        @name = "basic.consume"
        @method_id = 20
        @index = 0x003C0014 # 60, 20, 3932180

        # @return
        def self.decode(data)
          offset = 0
          ticket = data[offset..(offset + 2)].unpack("n").first
          offset += 2
          length = data[offset..(offset + 1)].unpack("c")[0]
          offset += 1
          queue = data[offset..(offset + length)]
          offset += length
          length = data[offset..(offset + 1)].unpack("c")[0]
          offset += 1
          consumer_tag = data[offset..(offset + length)]
          offset += length
          bit_buffer = data[offset..(offset + 1)].unpack("c").first
          offset += 1
          no_local = (bit_buffer & (1 << 0)) != 0
          table_length = Table.length(data[offset..(offset + 4)])
          arguments = Table.decode(data[offset..table_length])
          self.new(ticket, queue, consumer_tag, no_local, no_ack, exclusive, nowait, arguments)
        end

        attr_reader :ticket, :queue, :consumer_tag, :no_local, :no_ack, :exclusive, :nowait, :arguments
        def initialize(ticket, queue, consumer_tag, no_local, no_ack, exclusive, nowait, arguments)
          @ticket = ticket
          @queue = queue
          @consumer_tag = consumer_tag
          @no_local = no_local
          @no_ack = no_ack
          @exclusive = exclusive
          @nowait = nowait
          @arguments = arguments
        end
      end

      class ConsumeOk < Method
        @name = "basic.consume-ok"
        @method_id = 21
        @index = 0x003C0015 # 60, 21, 3932181

        # @return
        # ["consumer_tag = 0"]
        def self.encode(consumer_tag)
          pieces = []
          pieces << [60, 21].pack("n2")
          pieces << consumer_tag.bytesize.chr
          pieces << consumer_tag
          buffer = pieces.join("")
          MethodFrame.new(buffer)
        end
      end

      class Cancel < Method
        @name = "basic.cancel"
        @method_id = 30
        @index = 0x003C001E # 60, 30, 3932190

        # @return
        def self.decode(data)
          offset = 0
          length = data[offset..(offset + 1)].unpack("c")[0]
          offset += 1
          consumer_tag = data[offset..(offset + length)]
          offset += length
          bit_buffer = data[offset..(offset + 1)].unpack("c").first
          offset += 1
          nowait = (bit_buffer & (1 << 0)) != 0
          self.new(consumer_tag, nowait)
        end

        attr_reader :consumer_tag, :nowait
        def initialize(consumer_tag, nowait)
          @consumer_tag = consumer_tag
          @nowait = nowait
        end
      end

      class CancelOk < Method
        @name = "basic.cancel-ok"
        @method_id = 31
        @index = 0x003C001F # 60, 31, 3932191

        # @return
        # ["consumer_tag = 0"]
        def self.encode(consumer_tag)
          pieces = []
          pieces << [60, 31].pack("n2")
          pieces << consumer_tag.bytesize.chr
          pieces << consumer_tag
          buffer = pieces.join("")
          MethodFrame.new(buffer)
        end
      end

      class Publish < Method
        @name = "basic.publish"
        @method_id = 40
        @index = 0x003C0028 # 60, 40, 3932200

        # @return
        def self.decode(data)
          offset = 0
          ticket = data[offset..(offset + 2)].unpack("n").first
          offset += 2
          length = data[offset..(offset + 1)].unpack("c")[0]
          offset += 1
          exchange = data[offset..(offset + length)]
          offset += length
          length = data[offset..(offset + 1)].unpack("c")[0]
          offset += 1
          routing_key = data[offset..(offset + length)]
          offset += length
          bit_buffer = data[offset..(offset + 1)].unpack("c").first
          offset += 1
          mandatory = (bit_buffer & (1 << 0)) != 0
          self.new(ticket, exchange, routing_key, mandatory, immediate)
        end

        attr_reader :ticket, :exchange, :routing_key, :mandatory, :immediate
        def initialize(ticket, exchange, routing_key, mandatory, immediate)
          @ticket = ticket
          @exchange = exchange
          @routing_key = routing_key
          @mandatory = mandatory
          @immediate = immediate
        end
      end

      class Return < Method
        @name = "basic.return"
        @method_id = 50
        @index = 0x003C0032 # 60, 50, 3932210

        # @return
        # ["reply_code = 0", "reply_text = """, "exchange = 0", "routing_key = 0", "user_headers = nil", "payload = """, "frame_size = nil"]
        def self.encode(reply_code, reply_text, exchange, routing_key, frame_size)
          pieces = []
          pieces << [60, 50].pack("n2")
          pieces << [reply_code].pack("n")
          pieces << reply_text.bytesize.chr
          pieces << reply_text
          pieces << exchange.bytesize.chr
          pieces << exchange
          pieces << routing_key.bytesize.chr
          pieces << routing_key
          buffer = pieces.join("")
          frames = [MethodFrame.new(buffer)]
          frames.push(*self.encode_body(payload, frame_size))
          frames << HeadersFrame.new(user_headers)
          return frames
        end
      end

      class Deliver < Method
        @name = "basic.deliver"
        @method_id = 60
        @index = 0x003C003C # 60, 60, 3932220

        # @return
        # ["consumer_tag = 0", "delivery_tag = 0", "redelivered = 0", "exchange = 0", "routing_key = 0", "user_headers = nil", "payload = """, "frame_size = nil"]
        def self.encode(consumer_tag, delivery_tag, redelivered, exchange, routing_key, frame_size)
          pieces = []
          pieces << [60, 60].pack("n2")
          pieces << consumer_tag.bytesize.chr
          pieces << consumer_tag
          pieces << [delivery_tag].pack(">Q")
          bit_buffer = 0
          bit_buffer = bit_buffer | (1 << 0) if redelivered
          pieces << [bit_buffer].pack("c")
          pieces << exchange.bytesize.chr
          pieces << exchange
          pieces << routing_key.bytesize.chr
          pieces << routing_key
          buffer = pieces.join("")
          frames = [MethodFrame.new(buffer)]
          frames.push(*self.encode_body(payload, frame_size))
          frames << HeadersFrame.new(user_headers)
          return frames
        end
      end

      class Get < Method
        @name = "basic.get"
        @method_id = 70
        @index = 0x003C0046 # 60, 70, 3932230

        # @return
        def self.decode(data)
          offset = 0
          ticket = data[offset..(offset + 2)].unpack("n").first
          offset += 2
          length = data[offset..(offset + 1)].unpack("c")[0]
          offset += 1
          queue = data[offset..(offset + length)]
          offset += length
          bit_buffer = data[offset..(offset + 1)].unpack("c").first
          offset += 1
          no_ack = (bit_buffer & (1 << 0)) != 0
          self.new(ticket, queue, no_ack)
        end

        attr_reader :ticket, :queue, :no_ack
        def initialize(ticket, queue, no_ack)
          @ticket = ticket
          @queue = queue
          @no_ack = no_ack
        end
      end

      class GetOk < Method
        @name = "basic.get-ok"
        @method_id = 71
        @index = 0x003C0047 # 60, 71, 3932231

        # @return
        # ["delivery_tag = 0", "redelivered = 0", "exchange = 0", "routing_key = 0", "message_count = 0", "user_headers = nil", "payload = """, "frame_size = nil"]
        def self.encode(delivery_tag, redelivered, exchange, routing_key, message_count, frame_size)
          pieces = []
          pieces << [60, 71].pack("n2")
          pieces << [delivery_tag].pack(">Q")
          bit_buffer = 0
          bit_buffer = bit_buffer | (1 << 0) if redelivered
          pieces << [bit_buffer].pack("c")
          pieces << exchange.bytesize.chr
          pieces << exchange
          pieces << routing_key.bytesize.chr
          pieces << routing_key
          pieces << [message_count].pack("N")
          buffer = pieces.join("")
          frames = [MethodFrame.new(buffer)]
          frames.push(*self.encode_body(payload, frame_size))
          frames << HeadersFrame.new(user_headers)
          return frames
        end
      end

      class GetEmpty < Method
        @name = "basic.get-empty"
        @method_id = 72
        @index = 0x003C0048 # 60, 72, 3932232

        # @return
        # ["cluster_id = """]
        def self.encode(cluster_id)
          pieces = []
          pieces << [60, 72].pack("n2")
          pieces << cluster_id.bytesize.chr
          pieces << cluster_id
          buffer = pieces.join("")
          MethodFrame.new(buffer)
        end
      end

      class Ack < Method
        @name = "basic.ack"
        @method_id = 80
        @index = 0x003C0050 # 60, 80, 3932240

        # @return
        def self.decode(data)
          offset = 0
          delivery_tag = data[offset..(offset + 8)].unpack("N2").first
          offset += 8
          bit_buffer = data[offset..(offset + 1)].unpack("c").first
          offset += 1
          multiple = (bit_buffer & (1 << 0)) != 0
          self.new(delivery_tag, multiple)
        end

        attr_reader :delivery_tag, :multiple
        def initialize(delivery_tag, multiple)
          @delivery_tag = delivery_tag
          @multiple = multiple
        end
      end

      class Reject < Method
        @name = "basic.reject"
        @method_id = 90
        @index = 0x003C005A # 60, 90, 3932250

        # @return
        def self.decode(data)
          offset = 0
          delivery_tag = data[offset..(offset + 8)].unpack("N2").first
          offset += 8
          bit_buffer = data[offset..(offset + 1)].unpack("c").first
          offset += 1
          requeue = (bit_buffer & (1 << 0)) != 0
          self.new(delivery_tag, requeue)
        end

        attr_reader :delivery_tag, :requeue
        def initialize(delivery_tag, requeue)
          @delivery_tag = delivery_tag
          @requeue = requeue
        end
      end

      class RecoverAsync < Method
        @name = "basic.recover-async"
        @method_id = 100
        @index = 0x003C0064 # 60, 100, 3932260

        # @return
        def self.decode(data)
          offset = 0
          bit_buffer = data[offset..(offset + 1)].unpack("c").first
          offset += 1
          requeue = (bit_buffer & (1 << 0)) != 0
          self.new(requeue)
        end

        attr_reader :requeue
        def initialize(requeue)
          @requeue = requeue
        end
      end

      class Recover < Method
        @name = "basic.recover"
        @method_id = 110
        @index = 0x003C006E # 60, 110, 3932270

        # @return
        def self.decode(data)
          offset = 0
          bit_buffer = data[offset..(offset + 1)].unpack("c").first
          offset += 1
          requeue = (bit_buffer & (1 << 0)) != 0
          self.new(requeue)
        end

        attr_reader :requeue
        def initialize(requeue)
          @requeue = requeue
        end
      end

      class RecoverOk < Method
        @name = "basic.recover-ok"
        @method_id = 111
        @index = 0x003C006F # 60, 111, 3932271

        # @return
        # []
        def self.encode()
          pieces = []
          pieces << [60, 111].pack("n2")
          buffer = pieces.join("")
          MethodFrame.new(buffer)
        end
      end
    end

    METHODS = begin
      Method.methods.inject(Hash.new) do |hash, klass|
        hash.merge!(klass.index => klass)
      end
    end
  end
end
