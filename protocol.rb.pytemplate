# encoding: utf-8
# encoding: binary

# THIS IS AN AUTOGENERATED FILE, DO NOT MODIFY
# IT DIRECTLY ! FOR CHANGES, PLEASE UPDATE CODEGEN.PY
# IN THE ROOT DIRECTORY OF THE AMQP-PROTOCOL REPOSITORY.<% import codegen_helpers as helpers %><% import re, codegen %>

require_relative "table.rb"
require_relative "frame.rb"

module AMQ
  module Protocol
    PROTOCOL_VERSION = "${spec.major}.${spec.minor}.${spec.revision}"
    PREAMBLE = "${'AMQP\\x00\\x%02x\\x%02x\\x%02x' % (spec.major, spec.minor, spec.revision)}"
    DEFAULT_PORT = ${spec.port}

    # caching
    EMPTY_STRING = "".freeze

    # @version 0.0.1
    # @return [Array] Collection of subclasses of AMQ::Protocol::Class.
    def self.classes
      Class.classes
    end

    # @version 0.0.1
    # @return [Array] Collection of subclasses of AMQ::Protocol::Method.
    def self.methods
      Method.methods
    end

    class Error < StandardError
      def initialize(message = "AMQP error")
        super(message)
      end
    end

    class FrameTypeError < Error
      def initialize(types)
        super("Must be one of #{types.inspect}")
      end
    end

    class EmptyResponseError < Error
      def initialize(message = "Empty response received from the server.")
        super(message)
      end
    end

    class BadResponseError < Error
      def initialize(argument, expected, actual)
        super("Argument #{argument} has to be #{expected.inspect}, was #{data.inspect}")
      end
    end

    class SoftError < Error
    end

    class HardError < Error
    end

    % for tuple in spec.constants:
    % if tuple[2] == "soft-error" or tuple[2] == "hard-error":
    class ${codegen.to_ruby_class_name(tuple[0])} < ${codegen.to_ruby_class_name(tuple[2])}
      VALUE = ${tuple[1]}
    end

    % endif
    % endfor

    # We don't instantiate the following classes,
    # as we don't actually need any per-instance state.
    # Also, this is pretty low-level functionality,
    # hence it should have a reasonable performance.
    # As everyone knows, garbage collector in MRI performs
    # really badly, which is another good reason for
    # not creating any objects, but only use class as
    # a struct. Creating classes is quite expensive though,
    # but here the inheritance comes handy and mainly
    # as we can't simply make a reference to a function,
    # we can't use a hash or an object. I've been also
    # considering to have just a bunch of methods, but
    # here's the problem, that after we'd require this file,
    # all these methods would become global which would
    # be a bad, bad thing to do.
    class Class
      @@classes = Array.new

      def self.method
        @method
      end

      def self.name
        @name
      end

      def self.inherited(base)
        if self == Class
          @@classes << base
        end
      end

      def self.classes
        @@classes
      end
    end

    class Method
      @@methods = Array.new
      def self.method
        @method
      end

      def self.name
        @name
      end

      def self.index
        @index
      end

      def self.inherited(base)
        if self == Method
          @@methods << base
        end
      end

      def self.methods
        @@methods
      end

      def self.split_headers(user_headers)
        properties, headers = {}, {}
        user_headers.each do |key, value|
          if Basic::PROPERTIES.has_key?(key) or Basic::PROPERTIES.has_key?(key.to_sym)
            properties[key] = value
          else
            headers[key] = value
          end
        end

        return props, headers
      end

      def self.encode_body(body, frame_size)
        # Spec is broken: Our errata says that it does define
        # something, but it just doesn't relate do method and
        # properties frames. Which makes it, well, suboptimal.
        # https://dev.rabbitmq.com/wiki/Amqp091Errata#section_11
        limit = frame_size - 7 - 1

        Array.new.tap do |array|
          while body
            payload, body = body[0..limit], body[limit..-1]
            # array << [0x03, payload]
            array << BodyFrame.new(payload)
          end
        end
      end

      # We can return different:
      # - instantiate given subclass of Method
      # - create an OpenStruct object
      # - create a hash
      # - yield params into the block rather than just return
      # @api plugin
      def self.instantiate(*args, &block)
        self.new(*args, &block)
        # or OpenStruct.new(args.first)
        # or args.first
        # or block.call(*args)
      end
    end

    % for klass in spec.classes :
    class ${klass.constant_name} < Class
      @name = "${klass.name}"
      @method = ${klass.index}

      % if klass.fields: ## only the Basic class has fields (refered as properties in the JSON)
      PROPERTIES = [
      % for field in klass.fields:
        :${field.ruby_name}, # ${spec.resolveDomain(field.domain)}
        % endfor
      ]

      % for f in klass.fields:
      # <% i = klass.fields.index(f) %>1 << ${15 - i}
      def self.encode_${f.ruby_name}(value)
        pieces = []
        % for line in helpers.genSingleEncode(spec, "result", f.domain):
        ${line}
        % endfor
        [${i}, ${"0x%04x" % ( 1 << (15-i),)}, result]
      end

      % endfor

      % endif

      % if klass.name == "basic" : ## TODO: not only basic, resp. in fact it's only this class, but not necessarily in the future, rather check if properties are empty #}
      def self.encode_properties(body_size, properties)
        pieces = Array.new(14) { AMQ::Protocol::EMPTY_STRING }
        flags = 0

        properties.each do |key, value|
          i, f, result = self.send(:"encode_#{key}", value)
          flags |= f
          pieces[i] = result
        end

        result = [CLASS_BASIC, 0, body_size, flags].pack("!HHQH")
        [0x02, result, pieces.join("")].join("")
      end

      #def self.decode_properties
      #  print "def %s(data, offset):" % (c.decode,)
      #  print "    props = {}"
      #  print "    flags, = struct.unpack_from('!H', data, offset)"
      #  print "    offset += 2"
      #  print "    assert (flags & 0x01) == 0"
      #  for i, f in enumerate(c.fields):
      #      print "    if (flags & 0x%04x): # 1 << %i" % (1 << (15-i), 15-i)
      #      fields = codegen_helpers.UnpackWrapper()
      #      fields.add(f.n, f.t)
      #      fields.do_print(" "*8, "props['%s']")
      #  print "    return props, offset"
      #end
      % endif

      % for method in klass.methods :
      class ${method.constant_name} < Method
        @name = "${klass.name}.${method.name}"
        @method = ${method.index}
        @index = ${method.binary()}

        % if (spec.type == "client" and method.accepted_by("client")) or (spec.type == "server" and method.accepted_by("server")):
        # @return
        def self.decode(data)
          offset = 0
          % for line in helpers.genDecodeMethodDefinition(spec, method):
          ${line}
          % endfor
          self.new(${', '.join([f.ruby_name for f in method.arguments])})
        end

        % if len(method.arguments) > 0:
        attr_reader ${', '.join([":" + f.ruby_name for f in method.arguments])}
        % endif
        def initialize(${', '.join([f.ruby_name for f in method.arguments])})
          % for f in method.arguments:
          @${f.ruby_name} = ${f.ruby_name}
          % endfor
        end
        % endif

        % if (spec.type == "client" and method.accepted_by("server")) or (spec.type == "server" and method.accepted_by("client")):
        # @return
        # ${method.params()}
        def self.encode(${(", ").join(method.not_ignored_args())})
          pieces = []
          pieces << [${klass.index}, ${method.index}].pack("n2")
          % for line in helpers.genEncodeMethodDefinition(spec, method):
          ${line}
          % endfor
          buffer = pieces.join("")
          % if "payload" in method.args() or "user_headers" in method.args():
          frames = [MethodFrame.new(buffer)]
          % if "payload" in method.args():
          frames.push(*self.encode_body(payload))
          % endif
          % if "user_headers" in method.args():
          frames << HeadersFrame.new(user_headers)
          % endif
          return frames
          % else:
          MethodFrame.new(buffer)
          % endif
        end
        % endif

      end

      % endfor
    end

    % endfor

    METHODS = begin
      Method.methods.inject(Hash.new) do |hash, klass|
        hash.merge!(klass.index => klass)
      end
    end
  end
end
