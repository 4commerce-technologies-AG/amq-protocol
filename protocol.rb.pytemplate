# encoding: utf-8

# THIS IS AN AUTOGENERATED FILE, DO NOT MODIFY
# IT DIRECTLY ! FOR CHANGES, PLEASE UPDATE CODEGEN.PY
# IN THE ROOT DIRECTORY OF THE AMQP-PROTOCOL REPOSITORY.

module AMQP
  module Protocol
    PROTOCOL_VERSION = "{{ spec.major }}.{{ spec.minor }}.{{ spec.revision }}"
    PREAMBLE = "{{ 'AMQP\\x00\\x%02x\\x%02x\\x%02x' % (spec.major, spec.minor, spec.revision) }}"
    DEFAULT_PORT = {{ spec.port }}

    # @version 0.0.1
    # @return [Array] Collection of subclasses of AMQP::Protocol::Class.
    def self.classes
      Class.classes
    end

    # @version 0.0.1
    # @return [Array] Collection of subclasses of AMQP::Protocol::Method.
    def self.methods
      Method.methods
    end

    class Error < StandardError
      def initialize(message = "AMQP error")
        super(message)
      end
    end

    class Frame
    end

    # We don't instantiate the following classes,
    # as we don't actually need any per-instance state.
    # Also, this is pretty low-level functionality,
    # hence it should have a reasonable performance.
    # As everyone knows, garbage collector in MRI performs
    # really badly, which is another good reason for
    # not creating any objects, but only use class as
    # a struct. Creating classes is quite expensive though,
    # but here the inheritance comes handy and mainly
    # as we can't simply make a reference to a function,
    # we can't use a hash or an object. I've been also
    # considering to have just a bunch of methods, but
    # here's the problem, that after we'd require this file,
    # all these methods would become global which would
    # be a bad, bad thing to do.
    class Class
      @@classes = Array.new

      def self.method
        @method
      end

      def self.name
        @name
      end

      def self.inherited(base)
        if self == Class
          @@classes << base
        end
      end

      def self.classes
        @@classes
      end
    end

    class Method
      @@methods = Array.new
      def self.method
        @method
      end

      def self.name
        @name
      end

      def self.inherited(base)
        if self == Method
          @@methods << base
        end
      end

      def self.methods
        @@methods
      end

      # def self.encode_basic_properties(body_size, props)
      #   pieces = Array.new(14) { String.new }
      #   flags = 0
      #   enc = ENCODE_PROPS_BASIC
      #
      #   for key in BASIC_PROPS_SET & set(props.iterkeys()):
      #       i, f, fun = enc[key]
      #       flags |= f
      #       pieces[i] = fun(props[key])
      #
      #   return (0x02, ''.join((
      #       struct.pack('!HHQH',
      #                   CLASS_BASIC, 0, body_size, flags),
      #       ''.join(pieces),
      #       ))
      #       )
      # end
      #
      # def self.split_headers(user_headers, properties_set)
      #   properties, headers = {}, {}
      #   user_headers.iteritems.each do |key, value|
      #     if properties_set.has_key?(key)
      #       properties[key] = value
      #     else
      #       headers[key] = value
      #     end
      #   end
      #
      #   return props, headers
      # end
      #
      # def self.encode_body(body, frame_size)
      #   # Spec is broken: Our errata says that it does define
      #   # something, but it just doesn't relate do method and
      #   # properties frames. Which makes it, well, suboptimal.
      #   # https://dev.rabbitmq.com/wiki/Amqp091Errata#section_11
      #   limit = frame_size - 7 - 1
      #
      #   Array.new.tap do |array|
      #     while body
      #       payload, body = body[:limit], body[limit:] # TODO: how to port this to Ruby??
      #       array << [0x03, payload]
      #     end
      #   end
      # end
    end

    {% for class in spec.classes %}
    class {{ class.constant_name }} < Class
      @name = "{{ class.name }}"
      @method = {{ class.index }}
      {% for method in class.methods %}
      class {{ method.constant_name }} < Method
        @name = "{{ class.name }}.{{ method.name }}"
        @method = {{ method.index }}
        {{ method.binary() }}

        {% if method.accepted_by("client") %}
        # @return
        def self.decode(data)
        end
        {% elif method.accepted_by("server") %}
        # @return
        def self.encode(*args)
        end
        {% endif %}
      end
      {% endfor %}
    end
    {% endfor %}
  end
end
